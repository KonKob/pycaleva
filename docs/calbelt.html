<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pycaleva.calbelt API documentation</title>
<meta name="description" content="TODO:
- Confidences are not needed when do not plot
- Calculate boundaries only once if no changes detected" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pycaleva.calbelt</code></h1>
</header>
<section id="section-intro">
<h2 id="todo">TODO:</h2>
<ul>
<li>Confidences are not needed when do not plot</li>
<li>Calculate boundaries only once if no changes detected</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
TODO: 
-------------
 - Confidences are not needed when do not plot
 - Calculate boundaries only once if no changes detected
&#39;&#39;&#39;


from collections import namedtuple
from math import sqrt, exp, pi, asin, atan, acos
import warnings

from tqdm import tqdm
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Patch

from scipy.stats import chi2
from scipy.special import logit, xlogy, expit
from scipy.integrate import quad as integrate
from scipy.optimize import brentq, minimize, NonlinearConstraint

import statsmodels.api as sm
import statsmodels.formula.api as smf



# DEFINE RETURN TYPE
calbelt_result = namedtuple(&#39;calbelt_result&#39;, [&#39;statistic&#39;, &#39;pvalue&#39;, &#39;fig&#39;])


# DEFINE Cumulative density functions for m degrees 1 to 4
#----------------------------------------------------------

# Some scary math :(
def cdf_m(T:float, m:int, outsample:bool, thres:float):
    &#34;&#34;&#34;Defines the cumulative density functions for calibration belt of m degrees 1 to 4.
        Available for external or internal evaluation of models.

    Args:
        T (float): Teststatistic.
        m (int): Degress of polynomial fit.
        outsample (bool): Set to True for &#39;external&#39; or False for &#39;internal&#39; evaluation.
        thres (float): The confidence level to use.

    Returns:
        cdf (float): The cdf value for calibration belt according to parameters. 
    &#34;&#34;&#34;
    pDegInc = 1 - thres
    k = chi2.ppf(1-pDegInc, 1)

    # EXTERNAL EVALUATION
    if (outsample):
        if (T &lt;= (m-1) * k ):
            return 0
        else:
            if m == 1:
                # EXTERNAL m=1
                return chi2.cdf(T, 2)

            elif m == 2:
                # EXTERNAL m=2
                return (
                    ((chi2.cdf(T, df = 1) - 1 + pDegInc + 
                     (-1) * sqrt(2)/sqrt(pi) * exp(-T/2) * (sqrt(T) - 
                    sqrt(k)))/pDegInc)
                )

            elif m == 3:
                # EXTERNAL m=3
                integrand1 = ( lambda y: (chi2.cdf(T - y, df = 1) - 1 + pDegInc) * chi2.pdf(y, df = 1) )
                integrand2 = ( lambda y: (sqrt(T - y) - sqrt(k)) * 1/sqrt(y) )

                integral1 = integrate(integrand1, lower = k, upper = T - k)[0]
                integral2 = integrate(integrand2, lower = k, upper = T - k)[0]

                num = (integral1 - exp(-T/2)/(2 * pi) * 2 * integral2)
                den = pDegInc**2
                return (num/den)

            elif m == 4:
                # EXTERNAL m=4
                integrand = ( lambda r: ( (r**2 * (exp(-(r**2)/2) - exp(-T/2)) * 
                    (-pi * sqrt(k)/(2 * r) + 2 * sqrt(k)/r * 
                    asin((r**2/k - 1)**(-1/2)) - 2 * atan((1 - 
                    2 * k/r**2)**(-1/2)) + 2 * sqrt(k)/r * atan((r**2/k - 
                    2)**(-1/2)) + 2 * atan(r/sqrt(k) * sqrt(r**2/k - 
                    2)) - 2 * sqrt(k)/r * atan(sqrt(r**2/k - 
                    2)))) )
                )
                
                integral = integrate(integrand, lower = sqrt(3 * k), upper = sqrt(T))[0]

                return ((2/(pi * pDegInc**2))**(3/2) * integral)

            else:
                # EXTERNEAL m&gt;4 is not defined!
                return NotImplemented

    # INTERNAL EVALUATION
    else:
        if (T &lt;= (m-2) * k):
            return 0
        else:
            if m == 1:
                # INTERNAL m=1 --&gt; Not defined as polynial fit starts with degree 2 for internal evaluation
                return NotImplemented

            elif m == 2:
                # INTERNAL m=2
                return chi2.cdf(T, 1)

            elif m == 3:
                # INTERNAL m=3
                integrand = ( lambda r: (r * exp(-(r**2)/2) * acos(sqrt(k)/r)) )
                
                integral = integrate(integrand, lower = sqrt(k), upper = sqrt(T))[0]
                return (2/(pi * pDegInc) * integral)

            elif m == 4:
                # INTERNAL m=4
                integrand = (lambda r: (r**2 * exp(-(r**2)/2) * (atan(sqrt(r**2/k * 
                                (r**2/k - 2))) - sqrt(k)/r * atan(sqrt(r**2/k - 
                                2)) - sqrt(k)/r * acos((r**2/k - 1)**(-1/2))))
                            )
                
                integral = integrate(integrand, lower = sqrt(2 * k), upper = sqrt(T))[0]
                return ((2/pi)**(3/2) * (pDegInc)**(-2) * integral)
            else:
                # INTERNAL m&gt;4 is not defined!
                return NotImplemented



# MAIN Class for CalibrationBelt Test and Plotting
#-----------------------------------------------------------------

class CalibrationBelt():

    def __init__(self, o:np.ndarray, e:np.ndarray, outsample:bool, subset = None, confLevels=[0.8, 0.95], thres=0.95, maxDeg = 4):
        
        # Check parameters
        self.__check_parameters(o,e,outsample,thres)

    
        if not subset is None:
            # Pick a random subset from data
            idx = np.random.choice(np.arange(len(o)), subset, replace=False)
            self.__o = o[idx]
            self.__e = e[idx]
        else:
            self.__o = o
            self.__e = e

        # Check if given data is valid
        self.__check_data(o, e)

        self.__n = len(self.__o)

        # Warn user at internal evaluation
        if not outsample:
            warnings.warn(&#34;Evaluation only valid for Logistic Regression Models&#34;);

        self.__outsample = outsample

        self.__confLevels = sorted(confLevels, reverse=True)
        self.__logit_e = logit(self.__e)   # Get logit form of predicted probabilities

        # Find polynomial fit using forward selection procedure
        self.__model, self.__m =  self.__forward_select(thres, maxDeg)

        # Get teststatistic and p-value
        self.__T, self.__pval = self.__test(thres)

        self.__boundaries = {}


    def __check_parameters(self, o, e, outsample, thres) -&gt; bool:
        if (len(o) != len(e)):
            raise ValueError(&#34;Observations o and Predictions p differ in size!&#34;)
        if not ( ((o==0) | (o==1)).all() ):
            raise ValueError(&#34;Observations o must be given as numpy array with binary class labels (0 or 1)!&#34;)
        if ( (e &lt; 0.0 ).any() or (e &gt; 1.0).any() ):
            raise ValueError(&#34;Predictions p must be given as numpy array with values in range 0.0 - 1.0&#34;)
        if (thres &lt; 0.0 or thres &gt; 1.0):
            raise ValueError(&#34;Threshold must be in range 0.0 - 1.0&#34;)
        if (abs( e.sum() - o.sum() ) &lt; 1e-04 ) and outsample == True:
            warnings.warn(&#34;Please set parameter outsample to &#39;false&#39; if the evaluated model was fit on this dataset!&#34;, &#34;UserWarning&#34;)
        return True

    def __check_data(self, o, e) -&gt; bool:
        no_outcome_variaton = ( o.sum() &lt;= 1 ) or ( o.sum() &gt;= (len(o) - 1) )

        if ( no_outcome_variaton ):
            raise ValueError(&#34;The number of events/non events in observations can not be less than 1.&#34;)

        return True       

    # Find polynomial fit using forward selection process
    def __forward_select(self, thres, maxDeg):
        family = sm.families.Binomial()
        m = 0

        if (self.__outsample):
            m_start = 1
            fit_formula = f&#34;o ~ {m_start} + &#34;
        else:
            m_start = 2
            fit_formula = f&#34;o ~ I(ge ** {m_start-1}) + &#34;
        
        data = {&#34;o&#34;: self.__o, &#34;ge&#34;: self.__logit_e}
        inv_chi2 = chi2.ppf(thres, 1)

        n = m_start
        while n &lt;= maxDeg:
            # Add new term
            fit_formula += f&#34;I(ge ** {n})&#34;

            fit_new = smf.glm(formula=fit_formula, data=data,family=family).fit()

            if n &gt; m_start:
                # Log-likelihood ratio test
                Dm = 2 * (fit.llf - fit_new.llf)

                # Use previous order for m if model does not improve
                if Dm &lt; inv_chi2:
                    m = n-1
                    break

            m = n
            fit = fit_new
            n += 1

            fit_formula += &#34; + &#34;

        return(fit, m)


    def __test(self, thres):
        llh = np.sum(xlogy(self.__o, self.__e) + xlogy(1 - self.__o, 1 - self.__e))
        T = 2 * (self.__model.llf - llh)
        pval = 1 - cdf_m(T, self.__m, self.__outsample, thres)

        return T, pval


    def _root_fun(self, x, *args):
        m, q, confidence = args
        return cdf_m(x, m, self.__outsample, q) - confidence


    def _fun(self, alpha, *args):
        geM, sign = args
        return sign * (alpha @ geM)


    def _jac(self, alpha, *args):
        geM, sign = args
        return sign * geM


    def __calculate_boundaries(self, confidence, size=50, q=.95, **kwargs):
        # Cache boundaries for each confidence interval to save the parameters used in their calculation.
        if confidence in self.__boundaries:
            params = self.__boundaries[confidence][&#34;params&#34;]

            # If a request for the same interval is requested
            # it is only calculted one of the parameters change.
            # The parameters that modify the belt are (size, q, m).
            # In the case `size` changes, we compute the boundaries
            # only if the new `size` is greater than the previously used.
            
            if (size &lt;= params[&#34;size&#34;] and
                    q == params[&#34;q&#34;] and
                    self.__m == params[&#34;m&#34;]):
                return self.boundaries[confidence][&#34;boundaries&#34;]

        # New parameters
        params = {&#34;size&#34;: size, &#34;q&#34;: q, &#34;m&#34;: self.__m}

        # Find ky
        if self.__outsample:
            ky = (self.__m - 1) * chi2.ppf(q, 1)
        else:
            ky = (self.__m - 2) * chi2.ppf(q, 1)

            try:
                cdf_m(ky, self.__m, self.__outsample, q)
            except:
                ky += 1e-04


        args = self.__m, q, confidence


        k = brentq(self._root_fun, ky, 40, args=args)

        # Calculate logit(E) matrix
        M = np.linspace([0], [self.__m], num = self.__m + 1, axis=1)
        Ge = logit(self.__e)[np.newaxis]
        GeM = Ge.T ** M

        # Upper boundary (Eq27)
        boundary = self.__model.llf - k / 2

        # Create subset based on size
        logit_sub = np.linspace(np.min(Ge), np.max(Ge), num=size//2)
        e_sub = np.linspace(np.min(self.__e), np.max(self.__e), num=size//2)
        Ge_sub = np.sort(np.append(logit_sub, logit(e_sub)))
        GeM_sub = Ge_sub[np.newaxis].T ** M

        # Constraint function (Eq27)
        def fun_lalpha(alpha):
            # Calculate probability
            alphaE = expit(GeM @ alpha)

            # Clip probability to epsilon so
            # we can compute log-likelihood
            eps = 1e-5
            alphaE = np.clip(alphaE, eps, 1-eps)

            # Compute Log-likelihood
            lalpha = xlogy(self.__o, alphaE) + xlogy(1-self.__o, 1-alphaE)
            return np.nansum(lalpha)

        def jac_lalpha(alpha):
            # Calculate probability
            alphaE = expit(GeM @ alpha)
            return (self.__o - alphaE) @ GeM


        constraints = NonlinearConstraint(
                fun_lalpha,
                boundary, 0,
                jac_lalpha,
                keep_feasible=True
            )

        def _minimize(args):
            return minimize(
                fun=self._fun, x0=self.__model.params, args=args,
                method=&#39;trust-constr&#39;, jac=self._jac,
                hess=lambda alpha, *args: np.zeros((self.__m+1,)),
                constraints=constraints, tol=1e-4
            ).x

        
        lower, upper = [], []
        for geM in tqdm(GeM_sub):
            
            # Minimize alpha to find lower bound
            args = (geM, 1)
            min_alpha = _minimize(args)

            # Maximize alpha to find upper bound
            args = (geM, -1)
            max_alpha = _minimize(args)

            # Calculate bounds
            lower.append(expit(min_alpha @ geM))
            upper.append(expit(max_alpha @ geM))


        # Save parameters
        boundaries = np.array([expit(Ge_sub), lower, upper]).T
        self.__boundaries[confidence] = {
            &#34;params&#34;: params,
            &#34;boundaries&#34;: boundaries
        }
        
        return boundaries


    # Return teststatistic and p-value
    def stats(self):
        return calbelt_result(self.__T, self.__pval, None)


    def __get_plot_text(self):
        infos = {&#34;Degree Fit&#34;:self.__m, &#34;n&#34;:self.__n, &#34;T&#34;:self.__T}

        lines = [&#39;{:&lt;10s}{:&gt;8d}&#39;.format(&#34;n&#34;,self.__n)]
        lines = []
        for k, v in infos.items():
            if (isinstance(v,int)):
                lines.append(&#39;{:&lt;10s}{:&gt;8d}&#39;.format(k,v))
            else:
                lines.append(&#39;{:&lt;10s}{:&gt;8.3f}&#39;.format(k,v))
        
        # Set text for p-value
        if self.__pval &lt; .001:
            lines.append(&#39;{:&lt;10s}{:&gt;8s}&#39;.format(&#34;p-value&#34;,&#34;&lt; 0.001&#34;))
        else:
            lines.append(&#39;{:&lt;10s}{:&gt;8.3f}&#39;.format(&#34;p-value&#34;,self.__pval))

        textstr = &#39;\n&#39;.join(lines)
        return textstr


    def plot(self, q=.95, **kwargs):

        for confidence in self.__confLevels:
            self.__calculate_boundaries(confidence, q=q, **kwargs)

        # Plot stats
        fig, ax = plt.subplots(1, figsize=(10,6))

        # Info Textbox upper left
        props = dict(boxstyle=&#39;round&#39;, facecolor=&#39;white&#39;, alpha=0.4)
        ax.text(0.00, 0.85, self.__get_plot_text(), fontsize=10, family=&#39;monospace&#39;, bbox=props)

        # Set primary color belt
        facecol = &#39;cornflowerblue&#39; 

        # Set alpha of colour for each confidence level
        col_alphas = np.linspace(start=0.9, stop=0.4, num=len(self.__confLevels) )
        
        legend_elements = []

        # Update boundary and legend for each confidence level
        for i,confLevel in enumerate(self.__confLevels):
            legend_elements.append( Patch(facecolor=facecol, alpha=col_alphas[i], label=f&#39;{int(confLevel*100)}%&#39;) )
            bound = self.__boundaries[confLevel][&#34;boundaries&#34;].T
            ax.fill_between(bound[0], bound[1], bound[2], color=&#39;white&#39;, alpha=1)
            ax.fill_between(bound[0], bound[1], bound[2], color=facecol, alpha=col_alphas[i])

        # Set legend
        ax.legend(title=&#39;Confidence level&#39;, handles=legend_elements, loc=&#39;lower right&#39;)

        ax.set_xlabel(&#39;Predicted Probability&#39;)
        ax.set_ylabel(&#39;Actual Probability&#39;)

        # Plot perfect calibration using doted line
        ax.plot([0, 1], [0, 1], &#34;k:&#34;)

        return calbelt_result(self.__T, self.__pval, fig)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pycaleva.calbelt.cdf_m"><code class="name flex">
<span>def <span class="ident">cdf_m</span></span>(<span>T: float, m: int, outsample: bool, thres: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the cumulative density functions for calibration belt of m degrees 1 to 4.
Available for external or internal evaluation of models.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>T</code></strong> :&ensp;<code>float</code></dt>
<dd>Teststatistic.</dd>
<dt><strong><code>m</code></strong> :&ensp;<code>int</code></dt>
<dd>Degress of polynomial fit.</dd>
<dt><strong><code>outsample</code></strong> :&ensp;<code>bool</code></dt>
<dd>Set to True for 'external' or False for 'internal' evaluation.</dd>
<dt><strong><code>thres</code></strong> :&ensp;<code>float</code></dt>
<dd>The confidence level to use.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>cdf (float): The cdf value for calibration belt according to parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cdf_m(T:float, m:int, outsample:bool, thres:float):
    &#34;&#34;&#34;Defines the cumulative density functions for calibration belt of m degrees 1 to 4.
        Available for external or internal evaluation of models.

    Args:
        T (float): Teststatistic.
        m (int): Degress of polynomial fit.
        outsample (bool): Set to True for &#39;external&#39; or False for &#39;internal&#39; evaluation.
        thres (float): The confidence level to use.

    Returns:
        cdf (float): The cdf value for calibration belt according to parameters. 
    &#34;&#34;&#34;
    pDegInc = 1 - thres
    k = chi2.ppf(1-pDegInc, 1)

    # EXTERNAL EVALUATION
    if (outsample):
        if (T &lt;= (m-1) * k ):
            return 0
        else:
            if m == 1:
                # EXTERNAL m=1
                return chi2.cdf(T, 2)

            elif m == 2:
                # EXTERNAL m=2
                return (
                    ((chi2.cdf(T, df = 1) - 1 + pDegInc + 
                     (-1) * sqrt(2)/sqrt(pi) * exp(-T/2) * (sqrt(T) - 
                    sqrt(k)))/pDegInc)
                )

            elif m == 3:
                # EXTERNAL m=3
                integrand1 = ( lambda y: (chi2.cdf(T - y, df = 1) - 1 + pDegInc) * chi2.pdf(y, df = 1) )
                integrand2 = ( lambda y: (sqrt(T - y) - sqrt(k)) * 1/sqrt(y) )

                integral1 = integrate(integrand1, lower = k, upper = T - k)[0]
                integral2 = integrate(integrand2, lower = k, upper = T - k)[0]

                num = (integral1 - exp(-T/2)/(2 * pi) * 2 * integral2)
                den = pDegInc**2
                return (num/den)

            elif m == 4:
                # EXTERNAL m=4
                integrand = ( lambda r: ( (r**2 * (exp(-(r**2)/2) - exp(-T/2)) * 
                    (-pi * sqrt(k)/(2 * r) + 2 * sqrt(k)/r * 
                    asin((r**2/k - 1)**(-1/2)) - 2 * atan((1 - 
                    2 * k/r**2)**(-1/2)) + 2 * sqrt(k)/r * atan((r**2/k - 
                    2)**(-1/2)) + 2 * atan(r/sqrt(k) * sqrt(r**2/k - 
                    2)) - 2 * sqrt(k)/r * atan(sqrt(r**2/k - 
                    2)))) )
                )
                
                integral = integrate(integrand, lower = sqrt(3 * k), upper = sqrt(T))[0]

                return ((2/(pi * pDegInc**2))**(3/2) * integral)

            else:
                # EXTERNEAL m&gt;4 is not defined!
                return NotImplemented

    # INTERNAL EVALUATION
    else:
        if (T &lt;= (m-2) * k):
            return 0
        else:
            if m == 1:
                # INTERNAL m=1 --&gt; Not defined as polynial fit starts with degree 2 for internal evaluation
                return NotImplemented

            elif m == 2:
                # INTERNAL m=2
                return chi2.cdf(T, 1)

            elif m == 3:
                # INTERNAL m=3
                integrand = ( lambda r: (r * exp(-(r**2)/2) * acos(sqrt(k)/r)) )
                
                integral = integrate(integrand, lower = sqrt(k), upper = sqrt(T))[0]
                return (2/(pi * pDegInc) * integral)

            elif m == 4:
                # INTERNAL m=4
                integrand = (lambda r: (r**2 * exp(-(r**2)/2) * (atan(sqrt(r**2/k * 
                                (r**2/k - 2))) - sqrt(k)/r * atan(sqrt(r**2/k - 
                                2)) - sqrt(k)/r * acos((r**2/k - 1)**(-1/2))))
                            )
                
                integral = integrate(integrand, lower = sqrt(2 * k), upper = sqrt(T))[0]
                return ((2/pi)**(3/2) * (pDegInc)**(-2) * integral)
            else:
                # INTERNAL m&gt;4 is not defined!
                return NotImplemented</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pycaleva.calbelt.CalibrationBelt"><code class="flex name class">
<span>class <span class="ident">CalibrationBelt</span></span>
<span>(</span><span>o: numpy.ndarray, e: numpy.ndarray, outsample: bool, subset=None, confLevels=[0.8, 0.95], thres=0.95, maxDeg=4)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CalibrationBelt():

    def __init__(self, o:np.ndarray, e:np.ndarray, outsample:bool, subset = None, confLevels=[0.8, 0.95], thres=0.95, maxDeg = 4):
        
        # Check parameters
        self.__check_parameters(o,e,outsample,thres)

    
        if not subset is None:
            # Pick a random subset from data
            idx = np.random.choice(np.arange(len(o)), subset, replace=False)
            self.__o = o[idx]
            self.__e = e[idx]
        else:
            self.__o = o
            self.__e = e

        # Check if given data is valid
        self.__check_data(o, e)

        self.__n = len(self.__o)

        # Warn user at internal evaluation
        if not outsample:
            warnings.warn(&#34;Evaluation only valid for Logistic Regression Models&#34;);

        self.__outsample = outsample

        self.__confLevels = sorted(confLevels, reverse=True)
        self.__logit_e = logit(self.__e)   # Get logit form of predicted probabilities

        # Find polynomial fit using forward selection procedure
        self.__model, self.__m =  self.__forward_select(thres, maxDeg)

        # Get teststatistic and p-value
        self.__T, self.__pval = self.__test(thres)

        self.__boundaries = {}


    def __check_parameters(self, o, e, outsample, thres) -&gt; bool:
        if (len(o) != len(e)):
            raise ValueError(&#34;Observations o and Predictions p differ in size!&#34;)
        if not ( ((o==0) | (o==1)).all() ):
            raise ValueError(&#34;Observations o must be given as numpy array with binary class labels (0 or 1)!&#34;)
        if ( (e &lt; 0.0 ).any() or (e &gt; 1.0).any() ):
            raise ValueError(&#34;Predictions p must be given as numpy array with values in range 0.0 - 1.0&#34;)
        if (thres &lt; 0.0 or thres &gt; 1.0):
            raise ValueError(&#34;Threshold must be in range 0.0 - 1.0&#34;)
        if (abs( e.sum() - o.sum() ) &lt; 1e-04 ) and outsample == True:
            warnings.warn(&#34;Please set parameter outsample to &#39;false&#39; if the evaluated model was fit on this dataset!&#34;, &#34;UserWarning&#34;)
        return True

    def __check_data(self, o, e) -&gt; bool:
        no_outcome_variaton = ( o.sum() &lt;= 1 ) or ( o.sum() &gt;= (len(o) - 1) )

        if ( no_outcome_variaton ):
            raise ValueError(&#34;The number of events/non events in observations can not be less than 1.&#34;)

        return True       

    # Find polynomial fit using forward selection process
    def __forward_select(self, thres, maxDeg):
        family = sm.families.Binomial()
        m = 0

        if (self.__outsample):
            m_start = 1
            fit_formula = f&#34;o ~ {m_start} + &#34;
        else:
            m_start = 2
            fit_formula = f&#34;o ~ I(ge ** {m_start-1}) + &#34;
        
        data = {&#34;o&#34;: self.__o, &#34;ge&#34;: self.__logit_e}
        inv_chi2 = chi2.ppf(thres, 1)

        n = m_start
        while n &lt;= maxDeg:
            # Add new term
            fit_formula += f&#34;I(ge ** {n})&#34;

            fit_new = smf.glm(formula=fit_formula, data=data,family=family).fit()

            if n &gt; m_start:
                # Log-likelihood ratio test
                Dm = 2 * (fit.llf - fit_new.llf)

                # Use previous order for m if model does not improve
                if Dm &lt; inv_chi2:
                    m = n-1
                    break

            m = n
            fit = fit_new
            n += 1

            fit_formula += &#34; + &#34;

        return(fit, m)


    def __test(self, thres):
        llh = np.sum(xlogy(self.__o, self.__e) + xlogy(1 - self.__o, 1 - self.__e))
        T = 2 * (self.__model.llf - llh)
        pval = 1 - cdf_m(T, self.__m, self.__outsample, thres)

        return T, pval


    def _root_fun(self, x, *args):
        m, q, confidence = args
        return cdf_m(x, m, self.__outsample, q) - confidence


    def _fun(self, alpha, *args):
        geM, sign = args
        return sign * (alpha @ geM)


    def _jac(self, alpha, *args):
        geM, sign = args
        return sign * geM


    def __calculate_boundaries(self, confidence, size=50, q=.95, **kwargs):
        # Cache boundaries for each confidence interval to save the parameters used in their calculation.
        if confidence in self.__boundaries:
            params = self.__boundaries[confidence][&#34;params&#34;]

            # If a request for the same interval is requested
            # it is only calculted one of the parameters change.
            # The parameters that modify the belt are (size, q, m).
            # In the case `size` changes, we compute the boundaries
            # only if the new `size` is greater than the previously used.
            
            if (size &lt;= params[&#34;size&#34;] and
                    q == params[&#34;q&#34;] and
                    self.__m == params[&#34;m&#34;]):
                return self.boundaries[confidence][&#34;boundaries&#34;]

        # New parameters
        params = {&#34;size&#34;: size, &#34;q&#34;: q, &#34;m&#34;: self.__m}

        # Find ky
        if self.__outsample:
            ky = (self.__m - 1) * chi2.ppf(q, 1)
        else:
            ky = (self.__m - 2) * chi2.ppf(q, 1)

            try:
                cdf_m(ky, self.__m, self.__outsample, q)
            except:
                ky += 1e-04


        args = self.__m, q, confidence


        k = brentq(self._root_fun, ky, 40, args=args)

        # Calculate logit(E) matrix
        M = np.linspace([0], [self.__m], num = self.__m + 1, axis=1)
        Ge = logit(self.__e)[np.newaxis]
        GeM = Ge.T ** M

        # Upper boundary (Eq27)
        boundary = self.__model.llf - k / 2

        # Create subset based on size
        logit_sub = np.linspace(np.min(Ge), np.max(Ge), num=size//2)
        e_sub = np.linspace(np.min(self.__e), np.max(self.__e), num=size//2)
        Ge_sub = np.sort(np.append(logit_sub, logit(e_sub)))
        GeM_sub = Ge_sub[np.newaxis].T ** M

        # Constraint function (Eq27)
        def fun_lalpha(alpha):
            # Calculate probability
            alphaE = expit(GeM @ alpha)

            # Clip probability to epsilon so
            # we can compute log-likelihood
            eps = 1e-5
            alphaE = np.clip(alphaE, eps, 1-eps)

            # Compute Log-likelihood
            lalpha = xlogy(self.__o, alphaE) + xlogy(1-self.__o, 1-alphaE)
            return np.nansum(lalpha)

        def jac_lalpha(alpha):
            # Calculate probability
            alphaE = expit(GeM @ alpha)
            return (self.__o - alphaE) @ GeM


        constraints = NonlinearConstraint(
                fun_lalpha,
                boundary, 0,
                jac_lalpha,
                keep_feasible=True
            )

        def _minimize(args):
            return minimize(
                fun=self._fun, x0=self.__model.params, args=args,
                method=&#39;trust-constr&#39;, jac=self._jac,
                hess=lambda alpha, *args: np.zeros((self.__m+1,)),
                constraints=constraints, tol=1e-4
            ).x

        
        lower, upper = [], []
        for geM in tqdm(GeM_sub):
            
            # Minimize alpha to find lower bound
            args = (geM, 1)
            min_alpha = _minimize(args)

            # Maximize alpha to find upper bound
            args = (geM, -1)
            max_alpha = _minimize(args)

            # Calculate bounds
            lower.append(expit(min_alpha @ geM))
            upper.append(expit(max_alpha @ geM))


        # Save parameters
        boundaries = np.array([expit(Ge_sub), lower, upper]).T
        self.__boundaries[confidence] = {
            &#34;params&#34;: params,
            &#34;boundaries&#34;: boundaries
        }
        
        return boundaries


    # Return teststatistic and p-value
    def stats(self):
        return calbelt_result(self.__T, self.__pval, None)


    def __get_plot_text(self):
        infos = {&#34;Degree Fit&#34;:self.__m, &#34;n&#34;:self.__n, &#34;T&#34;:self.__T}

        lines = [&#39;{:&lt;10s}{:&gt;8d}&#39;.format(&#34;n&#34;,self.__n)]
        lines = []
        for k, v in infos.items():
            if (isinstance(v,int)):
                lines.append(&#39;{:&lt;10s}{:&gt;8d}&#39;.format(k,v))
            else:
                lines.append(&#39;{:&lt;10s}{:&gt;8.3f}&#39;.format(k,v))
        
        # Set text for p-value
        if self.__pval &lt; .001:
            lines.append(&#39;{:&lt;10s}{:&gt;8s}&#39;.format(&#34;p-value&#34;,&#34;&lt; 0.001&#34;))
        else:
            lines.append(&#39;{:&lt;10s}{:&gt;8.3f}&#39;.format(&#34;p-value&#34;,self.__pval))

        textstr = &#39;\n&#39;.join(lines)
        return textstr


    def plot(self, q=.95, **kwargs):

        for confidence in self.__confLevels:
            self.__calculate_boundaries(confidence, q=q, **kwargs)

        # Plot stats
        fig, ax = plt.subplots(1, figsize=(10,6))

        # Info Textbox upper left
        props = dict(boxstyle=&#39;round&#39;, facecolor=&#39;white&#39;, alpha=0.4)
        ax.text(0.00, 0.85, self.__get_plot_text(), fontsize=10, family=&#39;monospace&#39;, bbox=props)

        # Set primary color belt
        facecol = &#39;cornflowerblue&#39; 

        # Set alpha of colour for each confidence level
        col_alphas = np.linspace(start=0.9, stop=0.4, num=len(self.__confLevels) )
        
        legend_elements = []

        # Update boundary and legend for each confidence level
        for i,confLevel in enumerate(self.__confLevels):
            legend_elements.append( Patch(facecolor=facecol, alpha=col_alphas[i], label=f&#39;{int(confLevel*100)}%&#39;) )
            bound = self.__boundaries[confLevel][&#34;boundaries&#34;].T
            ax.fill_between(bound[0], bound[1], bound[2], color=&#39;white&#39;, alpha=1)
            ax.fill_between(bound[0], bound[1], bound[2], color=facecol, alpha=col_alphas[i])

        # Set legend
        ax.legend(title=&#39;Confidence level&#39;, handles=legend_elements, loc=&#39;lower right&#39;)

        ax.set_xlabel(&#39;Predicted Probability&#39;)
        ax.set_ylabel(&#39;Actual Probability&#39;)

        # Plot perfect calibration using doted line
        ax.plot([0, 1], [0, 1], &#34;k:&#34;)

        return calbelt_result(self.__T, self.__pval, fig)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycaleva.calbelt.CalibrationBelt.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, q=0.95, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, q=.95, **kwargs):

    for confidence in self.__confLevels:
        self.__calculate_boundaries(confidence, q=q, **kwargs)

    # Plot stats
    fig, ax = plt.subplots(1, figsize=(10,6))

    # Info Textbox upper left
    props = dict(boxstyle=&#39;round&#39;, facecolor=&#39;white&#39;, alpha=0.4)
    ax.text(0.00, 0.85, self.__get_plot_text(), fontsize=10, family=&#39;monospace&#39;, bbox=props)

    # Set primary color belt
    facecol = &#39;cornflowerblue&#39; 

    # Set alpha of colour for each confidence level
    col_alphas = np.linspace(start=0.9, stop=0.4, num=len(self.__confLevels) )
    
    legend_elements = []

    # Update boundary and legend for each confidence level
    for i,confLevel in enumerate(self.__confLevels):
        legend_elements.append( Patch(facecolor=facecol, alpha=col_alphas[i], label=f&#39;{int(confLevel*100)}%&#39;) )
        bound = self.__boundaries[confLevel][&#34;boundaries&#34;].T
        ax.fill_between(bound[0], bound[1], bound[2], color=&#39;white&#39;, alpha=1)
        ax.fill_between(bound[0], bound[1], bound[2], color=facecol, alpha=col_alphas[i])

    # Set legend
    ax.legend(title=&#39;Confidence level&#39;, handles=legend_elements, loc=&#39;lower right&#39;)

    ax.set_xlabel(&#39;Predicted Probability&#39;)
    ax.set_ylabel(&#39;Actual Probability&#39;)

    # Plot perfect calibration using doted line
    ax.plot([0, 1], [0, 1], &#34;k:&#34;)

    return calbelt_result(self.__T, self.__pval, fig)</code></pre>
</details>
</dd>
<dt id="pycaleva.calbelt.CalibrationBelt.stats"><code class="name flex">
<span>def <span class="ident">stats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stats(self):
    return calbelt_result(self.__T, self.__pval, None)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pycaleva.calbelt.calbelt_result"><code class="flex name class">
<span>class <span class="ident">calbelt_result</span></span>
<span>(</span><span>statistic, pvalue, fig)</span>
</code></dt>
<dd>
<div class="desc"><p>calbelt_result(statistic, pvalue, fig)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pycaleva.calbelt.calbelt_result.fig"><code class="name">var <span class="ident">fig</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="pycaleva.calbelt.calbelt_result.pvalue"><code class="name">var <span class="ident">pvalue</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="pycaleva.calbelt.calbelt_result.statistic"><code class="name">var <span class="ident">statistic</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<a href="./index.html"><img src="img/logo.svg" /></a>
<div class="toc">
<ul>
<li><a href="#todo">TODO:</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pycaleva" href="index.html">pycaleva</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pycaleva.calbelt.cdf_m" href="#pycaleva.calbelt.cdf_m">cdf_m</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pycaleva.calbelt.CalibrationBelt" href="#pycaleva.calbelt.CalibrationBelt">CalibrationBelt</a></code></h4>
<ul class="">
<li><code><a title="pycaleva.calbelt.CalibrationBelt.plot" href="#pycaleva.calbelt.CalibrationBelt.plot">plot</a></code></li>
<li><code><a title="pycaleva.calbelt.CalibrationBelt.stats" href="#pycaleva.calbelt.CalibrationBelt.stats">stats</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pycaleva.calbelt.calbelt_result" href="#pycaleva.calbelt.calbelt_result">calbelt_result</a></code></h4>
<ul class="">
<li><code><a title="pycaleva.calbelt.calbelt_result.fig" href="#pycaleva.calbelt.calbelt_result.fig">fig</a></code></li>
<li><code><a title="pycaleva.calbelt.calbelt_result.pvalue" href="#pycaleva.calbelt.calbelt_result.pvalue">pvalue</a></code></li>
<li><code><a title="pycaleva.calbelt.calbelt_result.statistic" href="#pycaleva.calbelt.calbelt_result.statistic">statistic</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>